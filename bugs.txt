#
# [file:#lines]
# desc
#
#    <code>
#

[http.c:105]
The reqpath buffer from zookd can be overflowed by sp1, because the function url_decode doesn't take into account 
length when it copies the contents of sp1 into reqpath, since reqpath is size 2048 while sp1 can be over length 8000. 
Since sp1 points to the first space in the request processed by http_request_line, in order to overflow the reqpath
buffer I would try to send a request in the format "GET /{?} HTTP 1.0 \r\n\r\n", where the {?} would be a string of 
length over 2048. Since reqpath is of size 2048 and the bad function url_decode copies from sp1 without checking
bounds, this should overflow reqpath and allow us to overwrite the return address for process_client in zookd.c. 
Stack canaries would help us avoid this vulnerablility, because we would not be able to overwrite the return address
in that case. 

	url_decode(reqpath, sp1);
	void url_decode(char *dst, const char *src)
	{
	    for (;;)
	    {
		if (src[0] == '%' && src[1] && src[2])
		{
		    char hexbuf[3];
		    hexbuf[0] = src[1];
		    hexbuf[1] = src[2];
		    hexbuf[2] = '\0';

		    *dst = strtol(&hexbuf[0], 0, 16);
		    src += 3;
		}
		else if (src[0] == '+')
		{
		    *dst = ' ';
		    src++;
		}
		else
		{
		    *dst = *src;
		    src++;

		    if (*dst == '\0')
			break;
		}

		dst++;
	    }
	}


[http.c:159]
The value[512] buffer can be overwritten by sp in the function http_request_headers because url_encode doesn't copy safely. Note that sp can be larger than 512 because the buffer static char buf it is a part of has size 8192. 

	/* Decode URL escape sequences in the value */
	url_decode(value, sp);




[http.c:107]
We can overflow the static buffer env[8192] in zookd, since it gets passed as a pointer into the function http_request_line. In the function http_request_line, it copies the contents of env[8192] to a local buffer buf[8192] in http_request_line. However, in the function, we process and split up the stuff in env and then add characters like "REQUEST_URI=". There is a check for how much user input (HTML request) to make sure it doesn't exceed 8192; however, we can make the buf in http_request_line contain enough characters to cause the addition of stuff like REQUEST_URI= and SERVER_PROTOCOL=
to overflow the env[8192] in zookd. 

	envp += sprintf(envp, "REQUEST_URI=%s", reqpath) + 1;
	
	
[http.c:12]
another description.

    <paste offending line(s) of code here>

[http.c:282]
The pn buffer can be overwritten by the name variable because of the strcat() function, which doesn't check the size
when it copies into pn. Since the name variable gets passed in with a larger possible size than pn (which is of size 1024), 
we can overflow pn and corrupt memory above this stack buffer. 

	char pn[1024];
	struct stat st;
	
	getcwd(pn, sizeof(pn));
	setenv("DOCUMENT_ROOT", pn, 1);

	strcat(pn, name);





