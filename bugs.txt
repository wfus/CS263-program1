#
# [file:#lines]
# desc
#
#    <code>
#

[http.c:105]
The reqpath buffer from zookd can be overflowed by sp1, because the function url_decode doesn't take into account 
length when it copies the contents of sp1 into reqpath, since reqpath is size 2048 while sp1 can be over length 8000. 

	url_decode(reqpath, sp1);
	void url_decode(char *dst, const char *src)
	{
	    for (;;)
	    {
		if (src[0] == '%' && src[1] && src[2])
		{
		    char hexbuf[3];
		    hexbuf[0] = src[1];
		    hexbuf[1] = src[2];
		    hexbuf[2] = '\0';

		    *dst = strtol(&hexbuf[0], 0, 16);
		    src += 3;
		}
		else if (src[0] == '+')
		{
		    *dst = ' ';
		    src++;
		}
		else
		{
		    *dst = *src;
		    src++;

		    if (*dst == '\0')
			break;
		}

		dst++;
	    }
	}


[http.c:159]
The value[512] buffer can be overwritten by sp in the function http_request_headers because url_encode doesn't copy safely. Note that sp can be larger than 512 because the buffer static char buf it is a part of has size 8192. 

	/* Decode URL escape sequences in the value */
	url_decode(value, sp);




[http.c:13]
We can overflow the static variable buf 

    <paste offending line(s) of code here>

[http.c:12]
another description.

    <paste offending line(s) of code here>

[http.c:282]
The pn buffer can be overwritten by the name variable because of the strcat() function, which doesn't check the size
when it copies into pn. Since the name variable gets passed in with a larger possible size than pn (which is of size 1024), 
we can overflow pn and corrupt memory above this stack buffer. 

	char pn[1024];
	struct stat st;
	
	getcwd(pn, sizeof(pn));
	setenv("DOCUMENT_ROOT", pn, 1);

	strcat(pn, name);





